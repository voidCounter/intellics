[
  {
    "lesson_id": 1,
    "module_id": 1,
    "lesson_name": "Introduction to Classes and Objects",
    "description": "Learn the fundamental concepts of classes and objects in Object-Oriented Programming.",
    "content": "# Introduction to Classes and Objects\n\nObject-Oriented Programming (OOP) is a programming paradigm based on the concept of **objects**, which can contain data and code. The data is in the form of fields (often known as attributes or properties), and the code is in the form of procedures (often known as methods).\n\n## What is a Class?\n\nA **class** is a blueprint or template for creating objects. It defines the structure and behavior that the objects created from it will have.\n\n```java\npublic class Car {\n    // Attributes (data)\n    private String brand;\n    private String model;\n    private int year;\n    \n    // Constructor\n    public Car(String brand, String model, int year) {\n        this.brand = brand;\n        this.model = model;\n        this.year = year;\n    }\n    \n    // Methods (behavior)\n    public void start() {\n        System.out.println(\"The car is starting...\");\n    }\n    \n    public void stop() {\n        System.out.println(\"The car is stopping...\");\n    }\n}\n```\n\n## What is an Object?\n\nAn **object** is an instance of a class. When you create an object, you're creating a specific example of the class with actual values.\n\n```java\n// Creating objects (instances) of the Car class\nCar myCar = new Car(\"Toyota\", \"Camry\", 2023);\nCar yourCar = new Car(\"Honda\", \"Civic\", 2022);\n\n// Using the objects\nmyCar.start();  // Output: The car is starting...\nyourCar.stop(); // Output: The car is stopping...\n```\n\n## Key Concepts\n\n1. **Encapsulation**: Bundling data and methods that operate on that data within a single unit (class)\n2. **Abstraction**: Hiding complex implementation details and showing only the essential features\n3. **Data Hiding**: Using access modifiers (private, protected, public) to control access to class members\n\n## Benefits of Using Classes and Objects\n\n- **Modularity**: Code is organized into discrete, manageable units\n- **Reusability**: Classes can be reused to create multiple objects\n- **Maintainability**: Changes to a class affect all objects of that class\n- **Data Security**: Private attributes protect data from unauthorized access"
  },
  {
    "lesson_id": 2,
    "module_id": 1,
    "lesson_name": "Inheritance and Polymorphism",
    "description": "Explore inheritance relationships and polymorphic behavior in object-oriented systems.",
    "content": "# Inheritance and Polymorphism\n\nInheritance and polymorphism are two fundamental pillars of Object-Oriented Programming that enable code reuse and flexible design.\n\n## Inheritance\n\n**Inheritance** allows a class to inherit properties and methods from another class. The class that inherits is called a **subclass** or **child class**, and the class being inherited from is called a **superclass** or **parent class**.\n\n```java\n// Parent class\npublic class Vehicle {\n    protected String brand;\n    protected int speed;\n    \n    public Vehicle(String brand) {\n        this.brand = brand;\n        this.speed = 0;\n    }\n    \n    public void accelerate() {\n        speed += 10;\n        System.out.println(brand + \" is accelerating. Speed: \" + speed);\n    }\n}\n\n// Child class\npublic class Car extends Vehicle {\n    private int numberOfDoors;\n    \n    public Car(String brand, int numberOfDoors) {\n        super(brand);  // Call parent constructor\n        this.numberOfDoors = numberOfDoors;\n    }\n    \n    public void honk() {\n        System.out.println(brand + \" is honking!\");\n    }\n}\n```\n\n## Polymorphism\n\n**Polymorphism** means \"many forms\". It allows objects of different types to be treated as objects of a common base type, while still maintaining their specific behavior.\n\n### Method Overriding\n\n```java\npublic class Motorcycle extends Vehicle {\n    public Motorcycle(String brand) {\n        super(brand);\n    }\n    \n    @Override\n    public void accelerate() {\n        speed += 15;  // Motorcycles accelerate faster\n        System.out.println(brand + \" motorcycle is accelerating quickly! Speed: \" + speed);\n    }\n}\n```\n\n### Polymorphic Behavior\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle[] vehicles = {\n            new Car(\"Toyota\", 4),\n            new Motorcycle(\"Harley\")\n        };\n        \n        // Polymorphism in action\n        for (Vehicle vehicle : vehicles) {\n            vehicle.accelerate();  // Calls the appropriate method\n        }\n    }\n}\n```\n\n## Types of Inheritance\n\n1. **Single Inheritance**: A class inherits from one parent class\n2. **Multilevel Inheritance**: A class inherits from a class that also inherits from another class\n3. **Hierarchical Inheritance**: Multiple classes inherit from a single parent class\n\n## Benefits\n\n- **Code Reuse**: Inherit common functionality from parent classes\n- **Extensibility**: Easy to add new features by extending existing classes\n- **Maintenance**: Changes to parent class automatically apply to child classes\n- **Flexibility**: Polymorphism allows for flexible and dynamic behavior"
  },
  {
    "lesson_id": 3,
    "module_id": 1,
    "lesson_name": "Encapsulation and Data Hiding",
    "description": "Master the principles of encapsulation and learn how to protect data using access modifiers.",
    "content": "# Encapsulation and Data Hiding\n\nEncapsulation is one of the core principles of Object-Oriented Programming that promotes data security and code organization.\n\n## What is Encapsulation?\n\n**Encapsulation** is the practice of bundling data (attributes) and methods that operate on that data within a single unit (class), while restricting direct access to some of the object's components.\n\n## Access Modifiers\n\nJava provides several access modifiers to control the visibility of class members:\n\n### 1. Private\n```java\npublic class BankAccount {\n    private double balance;  // Only accessible within this class\n    private String accountNumber;\n    \n    // Constructor\n    public BankAccount(String accountNumber, double initialBalance) {\n        this.accountNumber = accountNumber;\n        this.balance = initialBalance;\n    }\n}\n```\n\n### 2. Public\n```java\npublic class BankAccount {\n    private double balance;\n    \n    // Public methods provide controlled access\n    public double getBalance() {\n        return balance;\n    }\n    \n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n        }\n    }\n}\n```\n\n### 3. Protected\n```java\npublic class Vehicle {\n    protected String engine;  // Accessible to subclasses\n    private String serialNumber;\n}\n\npublic class Car extends Vehicle {\n    public void startEngine() {\n        // Can access protected member from parent\n        System.out.println(\"Starting \" + engine);\n    }\n}\n```\n\n### 4. Package-Private (Default)\n```java\nclass Helper {  // Package-private class\n    int value;  // Package-private field\n    \n    void process() {  // Package-private method\n        // Accessible within the same package\n    }\n}\n```\n\n## Getters and Setters\n\nGetters and setters provide controlled access to private data:\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    private double gpa;\n    \n    // Getter methods\n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public double getGpa() {\n        return gpa;\n    }\n    \n    // Setter methods with validation\n    public void setName(String name) {\n        if (name != null && !name.trim().isEmpty()) {\n            this.name = name;\n        }\n    }\n    \n    public void setAge(int age) {\n        if (age >= 0 && age <= 120) {\n            this.age = age;\n        }\n    }\n    \n    public void setGpa(double gpa) {\n        if (gpa >= 0.0 && gpa <= 4.0) {\n            this.gpa = gpa;\n        }\n    }\n}\n```\n\n## Benefits of Encapsulation\n\n1. **Data Protection**: Prevents unauthorized access and modification\n2. **Validation**: Control how data is set and retrieved\n3. **Flexibility**: Can change internal implementation without affecting external code\n4. **Debugging**: Easier to track where data is modified\n5. **Security**: Sensitive information can be hidden from external access\n\n## Best Practices\n\n- Make instance variables private by default\n- Provide public methods for necessary access\n- Validate input in setter methods\n- Use meaningful names for getter and setter methods\n- Consider whether every private field needs public access methods"
  }
]